{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"extensibility/component/","text":"Create a custom web component \u00b6 A web component is a custom HTML element that can be used in your templates to implement complex behaviors. We used them here as \"wrappers\" for React components to be able to use them with Handlebars. In this solution, web components are considered * stateless , meaning they will be entirely recreated when an attribute is changed (coming from the property pane). It means you can still use an inner state in your React components but not rely on the parent context (props) since it will be recreated every time by the Handlebars template. To create a custom component, follow this procedure: Create a new JSX file that will be used for your layout. (ex: CustomComponent.tsx ). You can create it anywhere in your project. Implement your component like a regular React component. import * as React from 'react'; import { BaseWebComponent } from '@aequos/extensibility'; import * as ReactDOM from 'react-dom'; export interface IObjectParam { myProperty: string; } export interface ICustomComponentProps { /** * A dummy string param */ myStringParam?: string; /*** * */ myObjectParam?: string; } export interface ICustomComponenState { } export class CustomComponent extends React.Component<ICustomComponentProps, ICustomComponenState> { public render() { // Parse custom object const myObject: IObjectParam = JSON.parse(this.props.myObjectParam); return <div>{this.props.myStringParam} {myObject.myProperty}</div>; } } Because props will be passed from an HTML template, they must to use always string type. For complex objects, you will need to pass them as 'stringified' then use the JSON.parse() method to use them in your component logic. In the same file, create an other class, this time to define your web component by inheriting the BaseWebComponent abstact class`: export class MyCustomComponentWebComponent extends BaseWebComponent { public constructor() { super(); } public async connectedCallback() { let props = this.resolveAttributes(); const debugView = <CustomComponent {...props}/>; ReactDOM.render(debugView, this); } } The resolveAttributes method will transform custom element HTML attributes to React component props. By convention, web component attributes have to be passed using camel case to be tranformed into React component props. For instance: a preview-image HTML attribute becomes previewImag prop. In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom components this way: import { IExtensibilityLibrary, IComponentDefinition } from \"@aequos/extensibility\"; import { MyCustomComponentWebComponent } from \"../CustomComponent\"; ... export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { ... public getCustomWebComponents(): IComponentDefinition<any>[] { return [ { componentName: 'my-custom-component', componentClass: MyCustomComponentWebComponent } ]; } ... In a custom Handlebars layout, reference your component like this, leveraging the Handlebars context values: <my-custom-component my-string-param=\"{{MyStringProperty}}\" my-object-param=\"{{JSONstringify MyObjectProperty 2}}\"></my-custom-component> Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog.","title":"Create a custom Web Component"},{"location":"extensibility/component/#create-a-custom-web-component","text":"A web component is a custom HTML element that can be used in your templates to implement complex behaviors. We used them here as \"wrappers\" for React components to be able to use them with Handlebars. In this solution, web components are considered * stateless , meaning they will be entirely recreated when an attribute is changed (coming from the property pane). It means you can still use an inner state in your React components but not rely on the parent context (props) since it will be recreated every time by the Handlebars template. To create a custom component, follow this procedure: Create a new JSX file that will be used for your layout. (ex: CustomComponent.tsx ). You can create it anywhere in your project. Implement your component like a regular React component. import * as React from 'react'; import { BaseWebComponent } from '@aequos/extensibility'; import * as ReactDOM from 'react-dom'; export interface IObjectParam { myProperty: string; } export interface ICustomComponentProps { /** * A dummy string param */ myStringParam?: string; /*** * */ myObjectParam?: string; } export interface ICustomComponenState { } export class CustomComponent extends React.Component<ICustomComponentProps, ICustomComponenState> { public render() { // Parse custom object const myObject: IObjectParam = JSON.parse(this.props.myObjectParam); return <div>{this.props.myStringParam} {myObject.myProperty}</div>; } } Because props will be passed from an HTML template, they must to use always string type. For complex objects, you will need to pass them as 'stringified' then use the JSON.parse() method to use them in your component logic. In the same file, create an other class, this time to define your web component by inheriting the BaseWebComponent abstact class`: export class MyCustomComponentWebComponent extends BaseWebComponent { public constructor() { super(); } public async connectedCallback() { let props = this.resolveAttributes(); const debugView = <CustomComponent {...props}/>; ReactDOM.render(debugView, this); } } The resolveAttributes method will transform custom element HTML attributes to React component props. By convention, web component attributes have to be passed using camel case to be tranformed into React component props. For instance: a preview-image HTML attribute becomes previewImag prop. In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom components this way: import { IExtensibilityLibrary, IComponentDefinition } from \"@aequos/extensibility\"; import { MyCustomComponentWebComponent } from \"../CustomComponent\"; ... export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { ... public getCustomWebComponents(): IComponentDefinition<any>[] { return [ { componentName: 'my-custom-component', componentClass: MyCustomComponentWebComponent } ]; } ... In a custom Handlebars layout, reference your component like this, leveraging the Handlebars context values: <my-custom-component my-string-param=\"{{MyStringProperty}}\" my-object-param=\"{{JSONstringify MyObjectProperty 2}}\"></my-custom-component> Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog.","title":"Create a custom web component"},{"location":"extensibility/datasource/","text":"Create a custom data source \u00b6 A complete example is available in the aequos GitHub repository. To create a custom data source, follow this procedure: Create a custom data source by creating a new class inheriting from the BaseDataSource abstract class. Also create an interface for your data source properties. You must create an interface even if empty. The data source properties are persisted in the Web Part property bag. Because the Web Part exposes only a subset of the property bag, you must prefix your property pane fields by the dataSourceProperties property to get it work (ex: PropertyPaneTextField(dataSourceProperties.myProperty', {...} ) import { BaseDataSource, IDataSourceData } from \"@aequos/extensibility\"; import { IPropertyPaneGroup } from \"@microsoft/sp-property-pane\"; import { PropertyPaneTextField } from '@microsoft/sp-webpart-base'; export interface ICustomDataSourceProperties { myProperty: string; } export class CustomDataSource extends BaseDataSource<ICustomDataSourceProperties> { public async getData(): Promise<IDataSourceData> { /* Your logic to get the data */ } public getPropertyPaneGroupsConfiguration(): IPropertyPaneGroup[] { return [ { groupName: \"Custom\", groupFields: [ /* Your property pane fields if needed (not mandatory) */ PropertyPaneTextField('dataSourceProperties.myProperty', { label: \"My custom property\" }) ] } ]; } } In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom data source this way: import { ServiceKey } from \"@microsoft/sp-core-library\"; import { IDataSourceDefinition, IDataSource, IExtensibilityLibrary } from \"@aequos/extensibility\"; import { CustomDataSource } from \"../CustomDataSource\"; export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { public getCustomDataSources(): IDataSourceDefinition[] { return [ { name: 'My Custom Source', iconName: 'Code', key: 'CustomDataSource', serviceKey: ServiceKey.create<IDataSource>('CustomDataSource', CustomDataSource) }, ]; } } The serviceKey property is used to create an instance of your data source dynamically. Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog. IMAGE_HERE Your custom data source will appear automatically in the Data Visualizer Web Part with associated property pane fields if specified: Debug your data source \u00b6 You can debug you data source like any regular SPFx solution: Bundle your solution to run locally using gulp bundle . Package your solution without the --ship option using gulp pacakge-solution Updload it to your site or global app catalog. Run the gulp serve --nobrowser command. Run the 'Hosted workbench' configuration in Visual Studio code and add the 'aequos - Modern data visualizer' Web Part. Use paging \u00b6 If your data source supports paging (for instance with $top and $skip tokens for OData REST APIs), you can benefit from the builtin template control to browse pages. By default, paging is turn to 'None' . <aequos-pagination total-items=\"{{@root.data.totalItemsCount}}\" items-count-per-page=\"{{@root.properties.paging.itemsCountPerPage}}\" current-page-number=\"{{@root.paging.currentPageNumber}}\"> </aequos-pagination> The paging control needs at least the following information to get it work: - Total items : the total items count returned by your data source query regardless the paging . Sometimes, this information is returned in a @data.count property in OData response. For instance, with SharePoint search, we use the TotalRows property. Coupled with Items count per page , this used to determine the number of pages to display in the control. You can provide this information by implementing the getTotalCount() method from the IDataSource interface. - Items count per page : the number of items to display per page. If you don't use paging, this corresponds simply to the number of items to retrieve (i.e only one page). This value is managed globally via an predefined proeprty pane property you should not use another Handlebars variable. - Current page number : the current selected page from the control. This value is managed globally in builtin paging feature and you should not use another Handlebars variable. The paging types are as follow. To specifiy the paging type your data source support, implement the getPagingType() method from the IDataSource interface. - PagingType.Static : with this option, the paging is done statically on the existing the data source items collection from the IDataSourceData interface. - PagingType.Dynamic : if you choose this option, the data source is responsible to fetch the correct data according to the current page and the number of items per page specified in settings. To achieve this, you must use we these two information from the dataContext property passed to the getData() method: public async getData(dataContext: DataContext): Promise<IDataSourceData> { // Fetch data for this page } The page number is literally the number of the page selected in the template control. It means the initial and minimum value for a page is 1 . It is your responsability to process this value and calculate your start row accordingly (i.e const startRow = pageNumber * itemsCountPerPage; ). Remember, for each paging type, you must implement the getItemCount() method in order to calculate the number of pages automatically. For static paging it could simply be the length of the items collection. Data source lifecycle methods \u00b6 The base class provides you some lifecycle hooks and method you can use to control the data source behavior: Method Description constructor(serviceScope: ServiceScope) Use the constructor to initialize your data source class private properties (not property pane properties). If you use the constructor, don't forget to call super(serviceScope) first. onInit() Called once during the first initialization of the Web Part at page load. Use this method to initializes property pane properties. This method can be asynchronous. onPropertyUpdate() Fired when a property pane property is updated. This will fire only with default SPFx property pane fields (ex: PropertyPaneTextField, PropertyPaneSlider, etc.). For custom control, you can control the lifecycle using this.render() and this.refresh() provided methods. getPropertyPaneGroupsConfiguration() Called when the Web Part proeprty pane is loaded to et your data source fields configuration. render() Use this method to manually trigger a complete render of the Web Part. Triggering this method will also fire the getData() method. refresh() Use this method to manually refresh the Web Part property pane. This can be useful if you create cascading fields with asynchronous values or use custom property pane fields. Use SharePoint Framework service scopes \u00b6 The data source system leverages the SPFx service scopes mechanism . A data source is always isolated in its own scope . Within this scope, you can consume both default SharePoint Framework services and custom provided ones. Use default SPFx services \u00b6 If you need to get a reference to SPHttpClient , MSGraphClient , etc. services to perform HTTP calls in your code. The base BaseDataSource class provides a serviceScope property you can use to consume shared services (SPFx or aequos). Add the following code pattern in the data source class in the onInit() method (not in the constructor). import { SPHttpClient } from \"@microsoft/sp-http\"; ... export class CustomDataSource extends BaseDataSource<ICustomDataSourceProperties> { private spHttpClient: SPHttpClient; public onInit() { // Use the already initialized 'serviceScope' property from the base class // Wait until the data source scope is finished. Calling 'consume' before won't work. this.serviceScope.whenFinished(() => { // Get an instance of the SPHttpClient class from the top root scope this.spHttpClient = serviceScope.consume<SPHttpClient>(SPHttpClient.serviceKey); }); } public async getData(): Promise<IDataSourceData> { // Do something with this.spHttpClient } ... Here are some useful SPFx services you can use in your data source: Service Description SPHttpClient Useful to make calls to the SharePoint REST API. HttpClient Useful to make calls to a generic REST API. MSGraphClientFactory Useful to malge calls to the Microsoft Graph REST API. PageContext Useful to get information about the current execution context like site and web URLs. aequos provided services \u00b6 We also provide custom services to help you building your data source. To consume such services, use the serviceKeys property provided by the base class to get service keys: TokenService : be able to use tokens within your property fields. serviceScope.whenFinished(() => { this.tokenService = serviceScope.consume<ITokenService>(this.serviceKeys.TokenService); ... }); Once instancied, resolve tokens using the resolveTokens() method: this.tokenService.resolveTokens(<your_string_property>); See Tokens to get the list of all supported tokens.","title":"Create a custom Data Source"},{"location":"extensibility/datasource/#create-a-custom-data-source","text":"A complete example is available in the aequos GitHub repository. To create a custom data source, follow this procedure: Create a custom data source by creating a new class inheriting from the BaseDataSource abstract class. Also create an interface for your data source properties. You must create an interface even if empty. The data source properties are persisted in the Web Part property bag. Because the Web Part exposes only a subset of the property bag, you must prefix your property pane fields by the dataSourceProperties property to get it work (ex: PropertyPaneTextField(dataSourceProperties.myProperty', {...} ) import { BaseDataSource, IDataSourceData } from \"@aequos/extensibility\"; import { IPropertyPaneGroup } from \"@microsoft/sp-property-pane\"; import { PropertyPaneTextField } from '@microsoft/sp-webpart-base'; export interface ICustomDataSourceProperties { myProperty: string; } export class CustomDataSource extends BaseDataSource<ICustomDataSourceProperties> { public async getData(): Promise<IDataSourceData> { /* Your logic to get the data */ } public getPropertyPaneGroupsConfiguration(): IPropertyPaneGroup[] { return [ { groupName: \"Custom\", groupFields: [ /* Your property pane fields if needed (not mandatory) */ PropertyPaneTextField('dataSourceProperties.myProperty', { label: \"My custom property\" }) ] } ]; } } In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom data source this way: import { ServiceKey } from \"@microsoft/sp-core-library\"; import { IDataSourceDefinition, IDataSource, IExtensibilityLibrary } from \"@aequos/extensibility\"; import { CustomDataSource } from \"../CustomDataSource\"; export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { public getCustomDataSources(): IDataSourceDefinition[] { return [ { name: 'My Custom Source', iconName: 'Code', key: 'CustomDataSource', serviceKey: ServiceKey.create<IDataSource>('CustomDataSource', CustomDataSource) }, ]; } } The serviceKey property is used to create an instance of your data source dynamically. Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog. IMAGE_HERE Your custom data source will appear automatically in the Data Visualizer Web Part with associated property pane fields if specified:","title":"Create a custom data source"},{"location":"extensibility/datasource/#debug-your-data-source","text":"You can debug you data source like any regular SPFx solution: Bundle your solution to run locally using gulp bundle . Package your solution without the --ship option using gulp pacakge-solution Updload it to your site or global app catalog. Run the gulp serve --nobrowser command. Run the 'Hosted workbench' configuration in Visual Studio code and add the 'aequos - Modern data visualizer' Web Part.","title":"Debug your data source"},{"location":"extensibility/datasource/#use-paging","text":"If your data source supports paging (for instance with $top and $skip tokens for OData REST APIs), you can benefit from the builtin template control to browse pages. By default, paging is turn to 'None' . <aequos-pagination total-items=\"{{@root.data.totalItemsCount}}\" items-count-per-page=\"{{@root.properties.paging.itemsCountPerPage}}\" current-page-number=\"{{@root.paging.currentPageNumber}}\"> </aequos-pagination> The paging control needs at least the following information to get it work: - Total items : the total items count returned by your data source query regardless the paging . Sometimes, this information is returned in a @data.count property in OData response. For instance, with SharePoint search, we use the TotalRows property. Coupled with Items count per page , this used to determine the number of pages to display in the control. You can provide this information by implementing the getTotalCount() method from the IDataSource interface. - Items count per page : the number of items to display per page. If you don't use paging, this corresponds simply to the number of items to retrieve (i.e only one page). This value is managed globally via an predefined proeprty pane property you should not use another Handlebars variable. - Current page number : the current selected page from the control. This value is managed globally in builtin paging feature and you should not use another Handlebars variable. The paging types are as follow. To specifiy the paging type your data source support, implement the getPagingType() method from the IDataSource interface. - PagingType.Static : with this option, the paging is done statically on the existing the data source items collection from the IDataSourceData interface. - PagingType.Dynamic : if you choose this option, the data source is responsible to fetch the correct data according to the current page and the number of items per page specified in settings. To achieve this, you must use we these two information from the dataContext property passed to the getData() method: public async getData(dataContext: DataContext): Promise<IDataSourceData> { // Fetch data for this page } The page number is literally the number of the page selected in the template control. It means the initial and minimum value for a page is 1 . It is your responsability to process this value and calculate your start row accordingly (i.e const startRow = pageNumber * itemsCountPerPage; ). Remember, for each paging type, you must implement the getItemCount() method in order to calculate the number of pages automatically. For static paging it could simply be the length of the items collection.","title":"Use paging"},{"location":"extensibility/datasource/#data-source-lifecycle-methods","text":"The base class provides you some lifecycle hooks and method you can use to control the data source behavior: Method Description constructor(serviceScope: ServiceScope) Use the constructor to initialize your data source class private properties (not property pane properties). If you use the constructor, don't forget to call super(serviceScope) first. onInit() Called once during the first initialization of the Web Part at page load. Use this method to initializes property pane properties. This method can be asynchronous. onPropertyUpdate() Fired when a property pane property is updated. This will fire only with default SPFx property pane fields (ex: PropertyPaneTextField, PropertyPaneSlider, etc.). For custom control, you can control the lifecycle using this.render() and this.refresh() provided methods. getPropertyPaneGroupsConfiguration() Called when the Web Part proeprty pane is loaded to et your data source fields configuration. render() Use this method to manually trigger a complete render of the Web Part. Triggering this method will also fire the getData() method. refresh() Use this method to manually refresh the Web Part property pane. This can be useful if you create cascading fields with asynchronous values or use custom property pane fields.","title":"Data source lifecycle methods"},{"location":"extensibility/datasource/#use-sharepoint-framework-service-scopes","text":"The data source system leverages the SPFx service scopes mechanism . A data source is always isolated in its own scope . Within this scope, you can consume both default SharePoint Framework services and custom provided ones.","title":"Use SharePoint Framework service scopes"},{"location":"extensibility/datasource/#use-default-spfx-services","text":"If you need to get a reference to SPHttpClient , MSGraphClient , etc. services to perform HTTP calls in your code. The base BaseDataSource class provides a serviceScope property you can use to consume shared services (SPFx or aequos). Add the following code pattern in the data source class in the onInit() method (not in the constructor). import { SPHttpClient } from \"@microsoft/sp-http\"; ... export class CustomDataSource extends BaseDataSource<ICustomDataSourceProperties> { private spHttpClient: SPHttpClient; public onInit() { // Use the already initialized 'serviceScope' property from the base class // Wait until the data source scope is finished. Calling 'consume' before won't work. this.serviceScope.whenFinished(() => { // Get an instance of the SPHttpClient class from the top root scope this.spHttpClient = serviceScope.consume<SPHttpClient>(SPHttpClient.serviceKey); }); } public async getData(): Promise<IDataSourceData> { // Do something with this.spHttpClient } ... Here are some useful SPFx services you can use in your data source: Service Description SPHttpClient Useful to make calls to the SharePoint REST API. HttpClient Useful to make calls to a generic REST API. MSGraphClientFactory Useful to malge calls to the Microsoft Graph REST API. PageContext Useful to get information about the current execution context like site and web URLs.","title":"Use default SPFx services"},{"location":"extensibility/datasource/#aequos-provided-services","text":"We also provide custom services to help you building your data source. To consume such services, use the serviceKeys property provided by the base class to get service keys: TokenService : be able to use tokens within your property fields. serviceScope.whenFinished(() => { this.tokenService = serviceScope.consume<ITokenService>(this.serviceKeys.TokenService); ... }); Once instancied, resolve tokens using the resolveTokens() method: this.tokenService.resolveTokens(<your_string_property>); See Tokens to get the list of all supported tokens.","title":"aequos provided services"},{"location":"extensibility/extensibility/","text":"Getting Started \u00b6 The Modern Data Visualizer solution allows you to customize the Web Part behavior in several ways: Custom Data Source : add your own data source options with personalized property pane fields Custom Layouts : add you own layouts options with a custon Handlebars template Custom Web Components : add you own components to be used in Handlebars template without the need to create a layout. A starter project is available on GitHub to help you to start your library. Prepare your project \u00b6 Create a new SharePoint Framework project of type 'Library Component' : yo @microsoft/sharepoint --environment spo --component-type library --solution-name MyCompanyLibrary In the package.json file, add the following dependencies and run a npm i : ... \"dependencies\": { ... \"@microsoft/sp-core-library\": \"1.9.1\", \"@microsoft/sp-property-pane\": \"1.9.1\", \"@microsoft/sp-webpart-base\": \"1.9.1\", \"@aequos/extensibility\": \"1.0.0\", \"typescript\": \"~3.3.0\" ... }, ... In the <your_library_name>.manifest.json file, replace the id property by the value dc4f961b-dbe0-44b4-982d-5776bf99d015 . This identifier is used to load dynamically the library from the Data Visualizer Web Part. Therefore, this value is mandatory to make the link. That is the only hook we need on your library. { // The value should be this id to make the link with the Web Part \"id\": \"dc4f961b-dbe0-44b4-982d-5776bf99d015\" / \"alias\": \"MyCompanyLibraryLibrary\", \"componentType\": \"Library\", ... }","title":"Getting started"},{"location":"extensibility/extensibility/#getting-started","text":"The Modern Data Visualizer solution allows you to customize the Web Part behavior in several ways: Custom Data Source : add your own data source options with personalized property pane fields Custom Layouts : add you own layouts options with a custon Handlebars template Custom Web Components : add you own components to be used in Handlebars template without the need to create a layout. A starter project is available on GitHub to help you to start your library.","title":"Getting Started"},{"location":"extensibility/extensibility/#prepare-your-project","text":"Create a new SharePoint Framework project of type 'Library Component' : yo @microsoft/sharepoint --environment spo --component-type library --solution-name MyCompanyLibrary In the package.json file, add the following dependencies and run a npm i : ... \"dependencies\": { ... \"@microsoft/sp-core-library\": \"1.9.1\", \"@microsoft/sp-property-pane\": \"1.9.1\", \"@microsoft/sp-webpart-base\": \"1.9.1\", \"@aequos/extensibility\": \"1.0.0\", \"typescript\": \"~3.3.0\" ... }, ... In the <your_library_name>.manifest.json file, replace the id property by the value dc4f961b-dbe0-44b4-982d-5776bf99d015 . This identifier is used to load dynamically the library from the Data Visualizer Web Part. Therefore, this value is mandatory to make the link. That is the only hook we need on your library. { // The value should be this id to make the link with the Web Part \"id\": \"dc4f961b-dbe0-44b4-982d-5776bf99d015\" / \"alias\": \"MyCompanyLibraryLibrary\", \"componentType\": \"Library\", ... }","title":"Prepare your project"},{"location":"extensibility/layout/","text":"Create a custom layout \u00b6 A layout is simply a custom HTML file To create a custom layout, follow this procedure: Create a new HTML file that will be used for your layout. (ex: custom-layout.html ). You can create it anywhere in your project: <content id=\"template\"> <style> /* Insert your CSS overrides here */ </style> <div class=\"template_root\"> <div>This is an external custom layout</div> <ul class=\"template_defaultList\"> {{#each data.items as |item|}} <li> {{MyDataSourceField}} </li> {{/each}} </ul> </div> </content> All your custom data source fields (items and custom properties) will be available in your template through the data root property (ex: data.items ). Also, don't forget to wrap your HTML markup with <content id=\"template\"> node to get it work. TODO Templating doc How to refer @root variable In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom layout this way: import { IExtensibilityLibrary, ILayoutDefinition } from \"@aequos/extensibility\"; export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { public getCustomLayouts(): ILayoutDefinition[] { return [ { name: 'My custom layout', iconName: 'Color', key: 'CustomLayout', templateContent: require('../custom-layout.html'), templateOptions: [ PropertyPaneTextField('customLayout.myTextProperty', { label: 'A custom layout property', placeholder: 'Fill a value' }) ] } ]; } Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog.","title":"Create a custom Layout"},{"location":"extensibility/layout/#create-a-custom-layout","text":"A layout is simply a custom HTML file To create a custom layout, follow this procedure: Create a new HTML file that will be used for your layout. (ex: custom-layout.html ). You can create it anywhere in your project: <content id=\"template\"> <style> /* Insert your CSS overrides here */ </style> <div class=\"template_root\"> <div>This is an external custom layout</div> <ul class=\"template_defaultList\"> {{#each data.items as |item|}} <li> {{MyDataSourceField}} </li> {{/each}} </ul> </div> </content> All your custom data source fields (items and custom properties) will be available in your template through the data root property (ex: data.items ). Also, don't forget to wrap your HTML markup with <content id=\"template\"> node to get it work. TODO Templating doc How to refer @root variable In the main entry point class (ex: MyCompanyLibraryLibrary.ts ), extends the IExtensibilityLibrary interface from the @aequos/extensibility module and register your custom layout this way: import { IExtensibilityLibrary, ILayoutDefinition } from \"@aequos/extensibility\"; export class MyCompanyLibraryLibrary implements IExtensibilityLibrary { public getCustomLayouts(): ILayoutDefinition[] { return [ { name: 'My custom layout', iconName: 'Color', key: 'CustomLayout', templateContent: require('../custom-layout.html'), templateOptions: [ PropertyPaneTextField('customLayout.myTextProperty', { label: 'A custom layout property', placeholder: 'Fill a value' }) ] } ]; } Bundle gulp bundle --ship and package your library gulp package-solution --ship and upload it either in the global or a site app catalog.","title":"Create a custom layout"},{"location":"faq/faq/","text":"Frequently Asked Questions \u00b6 You said the 'Data Visualizer' solution is an upgrade from the open source PnP 'Modern Search solution', so basically, you simply reused the same code but now make people pay for it? Absolutely not! We started the code from scratch with a completely new design approach. Of course we reuse pattern from the open source solution but there the majority of the codebase is totally new (and much improved from the free version). You may notice this is now much more than only SharePoint search Web Parts. I don't want a subscription based model. Can I just buy a 'standalone' version of the solution? Of course! Along the subscription model, we provide a standalone option with a license key. All you need is to setup a tenant property in your Office 365 tenant to get it work. It is slightly more expensive than the subscription based model, but it all depends how long you plan to use this solution.","title":"Frequently Asked Questions"},{"location":"faq/faq/#frequently-asked-questions","text":"You said the 'Data Visualizer' solution is an upgrade from the open source PnP 'Modern Search solution', so basically, you simply reused the same code but now make people pay for it? Absolutely not! We started the code from scratch with a completely new design approach. Of course we reuse pattern from the open source solution but there the majority of the codebase is totally new (and much improved from the free version). You may notice this is now much more than only SharePoint search Web Parts. I don't want a subscription based model. Can I just buy a 'standalone' version of the solution? Of course! Along the subscription model, we provide a standalone option with a license key. All you need is to setup a tenant property in your Office 365 tenant to get it work. It is slightly more expensive than the subscription based model, but it all depends how long you plan to use this solution.","title":"Frequently Asked Questions"},{"location":"getting_started/builtin_datasources/","text":"Available data sources \u00b6 The following data sources are available in the data visualizer Web Part: Source Description Static Data Displays a static set of JSON data. OData Retrieves data from OData APIs like Microsoft Graph, SharePoint REST, AAD Secured API or Anonymous API. CAML Retrieves data from SharePoint using a CAML query. Be careful, when you switch the data source in the property pane, all the previous data source properties are lost. We do this to avoid polluting the Web Part property bag. Static data source \u00b6 When working with static data, you will need to respect the following interface: { items: [ { MyItemProperty1: \"Property Value 1\", ... } ], MyContextProperty: \"My Value\", ... } Even if you don't return items, you must specifiy this property. In this case, pass an empty array. OData data source \u00b6 The OData data source allows you to get data from the following APIs Microsoft Graph : both v1.0 or beta endpoint. SharePoint REST API : the current site or an other site in your tenant. Azure Active Directoy secured API like an Azure function, Azure Web Application, etc. Anonymous API Microsoft Graph \u00b6 The URL supports the following formats: * me * /me * https://graph.microsoft.com/v1.0/me * https://graph.microsoft.com/beta/me * me/events?$filter=startswith(subject, 'ship') Before using a Microsoft Graph resource, you need to ensure you allowed the correct API permissions at tenant level . Because you can't define API permissions through the Web Part package declaratively (i.e webApiPermissions ), we recommend you to use the PnP Office 365 CLI to add correct permissions for your API: o365$ spo serviceprincipal grant add --resource 'Microsoft Graph' --scope 'Mail.Read' SharePoint REST API \u00b6 The URL supports the following formats: /_api/ (will target the root site) /_api/ (ex: http://mycompany.sharepoint.com/sites/intranet/_api/lists) all query parameters supported by the API . Azure Active Directory secured API \u00b6 Follow this procedure to set up your Azure Active Directory application. Don't forget to add at least the ' user impersonation ' permission to be able to call the API endpoint. Before using an AAD secured resource, you need to ensure you allowed the correct API permissions at tenant level . Because you can't define API permissions through the Web Part package declaratively (i.e webApiPermissions ), we recommend you to use the PnP Office 365 CLI to add correct permissions for your API: o365$ spo serviceprincipal grant add --resource '<aad_app_display_name>' --scope 'user_impersonation' Allow your SharePoint domain (ex: https://mycompany.sharepoint.com) as allowed origin in the service or application CORS (Cross-origin resource sharing) settings. Here a procedure for an Azure function . Anonymous \u00b6 You can also call an API endpoint with no specific authentifcation like an Azure Http trigger Function with function code. By default, we use the demo OData v4 services provided by https://www.odata.org/odata-services/ to demonstrate the capability. Set HTTP headers or body \u00b6 The only method allowed are GET or POST . For each, you have the ability so set your own HTTP headers. The value must be a valid JSON value : { \"Content-Type\": \"application/json;odata=verbose\", \"Accept\": \"application/json\", ... } If you specify a POST request, you can also benefit of builtin tokens . { \"ItemsCount\": \"{itemsCountPerPage}\", \"MyProperty\": \"My Value\", ... } Pagination \u00b6 For each API type, you can control how the results will be paginated in order to improve performances. Dynamic paging \u00b6 Use a Dynamic paging if the underlying API you are using supports paging mechanisms (likely using $top and $skip or $skipToken tokens, for instance Microsoft Graph or SharePoint REST API). Use server-side paging \u00b6 Some APIs like Microsoft Graph or the SharePoint REST API provide a server-side paging functionality (see https://docs.microsoft.com/en-us/graph/paging for more information). Basically, it allows you to paginate results more easily by using a pre-calculated next page link URL instead of building it manually. If checked, the paging will be based on the @odata.nextLink value from the HTTP response. It means when you will click on the next page button, this value will be used to get the next set of results. Thus, the items count and paging information (i.e first page, current page, next page, previous page, and last page) will be determined automatically as long as you move through pages. If unchecked, it will be your URL to be executed to get the next page results. In this last scenario you likely want to provide a dynamic URL using builtin tokens . Example With server-side paging enabled using @odata.nextLink : /me/messages?$top={itemsCountPerPage} or /me/messages?$top=2 Here, the $skip token will be provided automatically in the @odata.nextLink so you don't have to provide it in the URL. Without server-side paging enabled using $top and $skip tokens: <your_sharepoint_site_url>/_api/lists?$top={itemsCountPerPage}&$skip={startRow} If you want to control the paging by yourself, you will have to provide a $skip value manually using builtin tokens. You can use the {itemsCountPerPage} and {startRow} tokens where {startRow} corresponds to the number or items per page * the current page number (start from 0) and {itemsCountPerPage} to the number of items per page configured in the property pane. The URL and the items count will be resolved dynamically based on these token values as long as you move through pages. Because we can't determine the total number of items, in some cases, the last page could be empty. It happens for example when the 'total items count'/'items count per page' is even (i.e. exact same number of items for each page). Static paging \u00b6 If performance is not an issue (i.e for a small chunk of data), you can also set a static paging on your data based on a results array. In this case, you will have to provide the response field to use as the items array to get the total items count. Then, configure the desired number items per page to generate pages dynamically. Example Static paging using the items array field. /me/messages?$top=10 SharePoint CAML \u00b6 If you don't specify view fields (not recommended), all fields from the list will be loaded an available in the template. The paging will be determined automatically base on the items count per page settings.","title":"Available data sources"},{"location":"getting_started/builtin_datasources/#available-data-sources","text":"The following data sources are available in the data visualizer Web Part: Source Description Static Data Displays a static set of JSON data. OData Retrieves data from OData APIs like Microsoft Graph, SharePoint REST, AAD Secured API or Anonymous API. CAML Retrieves data from SharePoint using a CAML query. Be careful, when you switch the data source in the property pane, all the previous data source properties are lost. We do this to avoid polluting the Web Part property bag.","title":"Available data sources"},{"location":"getting_started/builtin_datasources/#static-data-source","text":"When working with static data, you will need to respect the following interface: { items: [ { MyItemProperty1: \"Property Value 1\", ... } ], MyContextProperty: \"My Value\", ... } Even if you don't return items, you must specifiy this property. In this case, pass an empty array.","title":"Static data source"},{"location":"getting_started/builtin_datasources/#odata-data-source","text":"The OData data source allows you to get data from the following APIs Microsoft Graph : both v1.0 or beta endpoint. SharePoint REST API : the current site or an other site in your tenant. Azure Active Directoy secured API like an Azure function, Azure Web Application, etc. Anonymous API","title":"OData data source"},{"location":"getting_started/builtin_datasources/#microsoft-graph","text":"The URL supports the following formats: * me * /me * https://graph.microsoft.com/v1.0/me * https://graph.microsoft.com/beta/me * me/events?$filter=startswith(subject, 'ship') Before using a Microsoft Graph resource, you need to ensure you allowed the correct API permissions at tenant level . Because you can't define API permissions through the Web Part package declaratively (i.e webApiPermissions ), we recommend you to use the PnP Office 365 CLI to add correct permissions for your API: o365$ spo serviceprincipal grant add --resource 'Microsoft Graph' --scope 'Mail.Read'","title":"Microsoft Graph"},{"location":"getting_started/builtin_datasources/#sharepoint-rest-api","text":"The URL supports the following formats: /_api/ (will target the root site) /_api/ (ex: http://mycompany.sharepoint.com/sites/intranet/_api/lists) all query parameters supported by the API .","title":"SharePoint REST API"},{"location":"getting_started/builtin_datasources/#azure-active-directory-secured-api","text":"Follow this procedure to set up your Azure Active Directory application. Don't forget to add at least the ' user impersonation ' permission to be able to call the API endpoint. Before using an AAD secured resource, you need to ensure you allowed the correct API permissions at tenant level . Because you can't define API permissions through the Web Part package declaratively (i.e webApiPermissions ), we recommend you to use the PnP Office 365 CLI to add correct permissions for your API: o365$ spo serviceprincipal grant add --resource '<aad_app_display_name>' --scope 'user_impersonation' Allow your SharePoint domain (ex: https://mycompany.sharepoint.com) as allowed origin in the service or application CORS (Cross-origin resource sharing) settings. Here a procedure for an Azure function .","title":"Azure Active Directory secured API"},{"location":"getting_started/builtin_datasources/#anonymous","text":"You can also call an API endpoint with no specific authentifcation like an Azure Http trigger Function with function code. By default, we use the demo OData v4 services provided by https://www.odata.org/odata-services/ to demonstrate the capability.","title":"Anonymous"},{"location":"getting_started/builtin_datasources/#set-http-headers-or-body","text":"The only method allowed are GET or POST . For each, you have the ability so set your own HTTP headers. The value must be a valid JSON value : { \"Content-Type\": \"application/json;odata=verbose\", \"Accept\": \"application/json\", ... } If you specify a POST request, you can also benefit of builtin tokens . { \"ItemsCount\": \"{itemsCountPerPage}\", \"MyProperty\": \"My Value\", ... }","title":"Set HTTP headers or body"},{"location":"getting_started/builtin_datasources/#pagination","text":"For each API type, you can control how the results will be paginated in order to improve performances.","title":"Pagination"},{"location":"getting_started/builtin_datasources/#dynamic-paging","text":"Use a Dynamic paging if the underlying API you are using supports paging mechanisms (likely using $top and $skip or $skipToken tokens, for instance Microsoft Graph or SharePoint REST API).","title":"Dynamic paging"},{"location":"getting_started/builtin_datasources/#use-server-side-paging","text":"Some APIs like Microsoft Graph or the SharePoint REST API provide a server-side paging functionality (see https://docs.microsoft.com/en-us/graph/paging for more information). Basically, it allows you to paginate results more easily by using a pre-calculated next page link URL instead of building it manually. If checked, the paging will be based on the @odata.nextLink value from the HTTP response. It means when you will click on the next page button, this value will be used to get the next set of results. Thus, the items count and paging information (i.e first page, current page, next page, previous page, and last page) will be determined automatically as long as you move through pages. If unchecked, it will be your URL to be executed to get the next page results. In this last scenario you likely want to provide a dynamic URL using builtin tokens . Example With server-side paging enabled using @odata.nextLink : /me/messages?$top={itemsCountPerPage} or /me/messages?$top=2 Here, the $skip token will be provided automatically in the @odata.nextLink so you don't have to provide it in the URL. Without server-side paging enabled using $top and $skip tokens: <your_sharepoint_site_url>/_api/lists?$top={itemsCountPerPage}&$skip={startRow} If you want to control the paging by yourself, you will have to provide a $skip value manually using builtin tokens. You can use the {itemsCountPerPage} and {startRow} tokens where {startRow} corresponds to the number or items per page * the current page number (start from 0) and {itemsCountPerPage} to the number of items per page configured in the property pane. The URL and the items count will be resolved dynamically based on these token values as long as you move through pages. Because we can't determine the total number of items, in some cases, the last page could be empty. It happens for example when the 'total items count'/'items count per page' is even (i.e. exact same number of items for each page).","title":"Use server-side paging"},{"location":"getting_started/builtin_datasources/#static-paging","text":"If performance is not an issue (i.e for a small chunk of data), you can also set a static paging on your data based on a results array. In this case, you will have to provide the response field to use as the items array to get the total items count. Then, configure the desired number items per page to generate pages dynamically. Example Static paging using the items array field. /me/messages?$top=10","title":"Static paging"},{"location":"getting_started/builtin_datasources/#sharepoint-caml","text":"If you don't specify view fields (not recommended), all fields from the list will be loaded an available in the template. The paging will be determined automatically base on the items count per page settings.","title":"SharePoint CAML"},{"location":"getting_started/builtin_layouts/","text":"Details list \u00b6 Icon type","title":"Available layouts"},{"location":"getting_started/builtin_layouts/#details-list","text":"Icon type","title":"Details list"},{"location":"getting_started/setup_standalone/","text":"Setup your standalone license \u00b6 Install Office 365 CLI : npm i -g @pnp/office365-cli Connect to Office 365 using the following command. o365$ login Create a new tenant property named AEQUOS_DATAVISUALIZER_LICENSE_KEY with, as value, the key you received by mail after your purchase: spo storageentity set -k AEQUOS_DATAVISUALIZER_LICENSE_KEY -v <your_key> -d 'aequos Data Visualizer solution license key' -u https://contoso.sharepoint.com/sites/appcatalog In the URL, you must specify the address of the global app catalog in your tenant. If you don't have an app catalog, follow this procedure to create one. To remove an existing key, use the following command: spo storageentity remove -k AEQUOS_DATAVISUALIZER_LICENSE_KEY -u https://contoso.sharepoint.com/sites/appcatalog","title":"Activate standalone license"},{"location":"getting_started/setup_standalone/#setup-your-standalone-license","text":"Install Office 365 CLI : npm i -g @pnp/office365-cli Connect to Office 365 using the following command. o365$ login Create a new tenant property named AEQUOS_DATAVISUALIZER_LICENSE_KEY with, as value, the key you received by mail after your purchase: spo storageentity set -k AEQUOS_DATAVISUALIZER_LICENSE_KEY -v <your_key> -d 'aequos Data Visualizer solution license key' -u https://contoso.sharepoint.com/sites/appcatalog In the URL, you must specify the address of the global app catalog in your tenant. If you don't have an app catalog, follow this procedure to create one. To remove an existing key, use the following command: spo storageentity remove -k AEQUOS_DATAVISUALIZER_LICENSE_KEY -u https://contoso.sharepoint.com/sites/appcatalog","title":"Setup your standalone license"},{"location":"templating/guidelines/","text":"Browsers compatibility \u00b6 This solution has been tested on the following browsers: Chrome Internet Explorer 11 Firefox Opera Safari TODO test versions Use SharePoint theme in your templates \u00b6 If you need to use current site theme colors, fonts and so on you can use the theme property available in the root Handlebars context like this: <content id=\"data-content\"> <style> .example-themePrimary { color: {{@root.theme.palette.themePrimary}}; } ... </styles> ... <span class=\"example-themePrimary\">{{Title}}</span> ... </content> For the cards and details list layouts, une the @theme context property instead: A good way to see all available values for the current theme is to switch to the debug layout and inspect these values: Work with placeholders \u00b6 To indicate the data are loading, you can create placeholders (shimmers) using the <content id=\"placeholder-content\"> section of your HTML template: The placeholder is only loaded during first data load. For subsequent requests, a overlay will be displayed. <content id=\"placeholder-content\"> <style> .placeholder .icon { width: 20px; height: 16px; margin-right: 5px; } .placeholder ul { list-style: none; } .placeholder ul li { display: flex; align-items: center; padding: 8px; } </style> <div class=\"placeholder\"> <ul> {{#times 5}} <li> <div class=\"icon placeholder--shimmer\"></div> <span class=\"placeholder--shimmer placeholder--line\" style=\"width: 60%\"></span> </li> {{/times}} </ul> </div> </content> Use CSS classes placeholder--shimmer and placeholder--line to build your placeholders. Basically, you can reuse the same HTML structure as your template content markup, but using these these classes instead to fill areas. If no placeholder is present in the template, a default one will be loaded. Cards layout \u00b6 The cards layout provides the following options: Option Description Manage card fields Allows you to define you own values for card placeholder fields. By default, the document card fields come with predefined mappings but you can set your own. As a field value, you can choose either an item property value from the list (available properties are all the fields returned by the current selected source across all items) without any transformation or use an Handlebars expression by clicking on the checkbox next to it. In this case, all helpers from the main template are available. Also, if the field doesn't have the 'Allow HTML' indication flag enabled, it means the value will be always interpreted as text, whatever if you set an HTML value. Otherwise, your value will be interpreted as HTML for those fields (ex: ' Location ' and ' Tags ' placeholder fields). For HTML fields you can use the special variable @theme to use theme colors (ex: @them.palette.themePrimary ). If you don't set a value for those fields (i.e an empty value), they won't appear in the UI: Enable result preview If enabled, displays a preview callout when the card image is clicked. This will works for office documents, pdf and Office 365 videos. Show file icon Hide or display the file icon in the card. Compact mode Display the cards in compact mode. Numbre of preferred cards per row Try to displays the selected number of cards in the current section. Because a card has a mininum width, the layout will always try to fit the maximum of cards inside the current Web Part section until reaching the layout option value you set. For example, if you specified five cards in a row but the Web Part is rendered in a single vertical section, only one card per row will be displayed regardless the option value. However, if you expand the Web Part in a full width column, the five cards per row will be displayed. This behavior ensures the layout will always render nicely in responsive scenarios. Details List Layout \u00b6 When you enable sorting for a column, the sort is performed on the initial item fiel value , not on the Handlebars expression if provided. If this option is checked, you can choose the item field to use to determine the right icon for instance ( .docx ). Work with result types \u00b6 A result types feature is available for List, Cards and Custom layouts. If you need to apply conditional result in the slider component, use direct conditions like {{#if}} inside the slider component.","title":"Templating guidelines"},{"location":"templating/guidelines/#browsers-compatibility","text":"This solution has been tested on the following browsers: Chrome Internet Explorer 11 Firefox Opera Safari TODO test versions","title":"Browsers compatibility"},{"location":"templating/guidelines/#use-sharepoint-theme-in-your-templates","text":"If you need to use current site theme colors, fonts and so on you can use the theme property available in the root Handlebars context like this: <content id=\"data-content\"> <style> .example-themePrimary { color: {{@root.theme.palette.themePrimary}}; } ... </styles> ... <span class=\"example-themePrimary\">{{Title}}</span> ... </content> For the cards and details list layouts, une the @theme context property instead: A good way to see all available values for the current theme is to switch to the debug layout and inspect these values:","title":"Use SharePoint theme in your templates"},{"location":"templating/guidelines/#work-with-placeholders","text":"To indicate the data are loading, you can create placeholders (shimmers) using the <content id=\"placeholder-content\"> section of your HTML template: The placeholder is only loaded during first data load. For subsequent requests, a overlay will be displayed. <content id=\"placeholder-content\"> <style> .placeholder .icon { width: 20px; height: 16px; margin-right: 5px; } .placeholder ul { list-style: none; } .placeholder ul li { display: flex; align-items: center; padding: 8px; } </style> <div class=\"placeholder\"> <ul> {{#times 5}} <li> <div class=\"icon placeholder--shimmer\"></div> <span class=\"placeholder--shimmer placeholder--line\" style=\"width: 60%\"></span> </li> {{/times}} </ul> </div> </content> Use CSS classes placeholder--shimmer and placeholder--line to build your placeholders. Basically, you can reuse the same HTML structure as your template content markup, but using these these classes instead to fill areas. If no placeholder is present in the template, a default one will be loaded.","title":"Work with placeholders"},{"location":"templating/guidelines/#cards-layout","text":"The cards layout provides the following options: Option Description Manage card fields Allows you to define you own values for card placeholder fields. By default, the document card fields come with predefined mappings but you can set your own. As a field value, you can choose either an item property value from the list (available properties are all the fields returned by the current selected source across all items) without any transformation or use an Handlebars expression by clicking on the checkbox next to it. In this case, all helpers from the main template are available. Also, if the field doesn't have the 'Allow HTML' indication flag enabled, it means the value will be always interpreted as text, whatever if you set an HTML value. Otherwise, your value will be interpreted as HTML for those fields (ex: ' Location ' and ' Tags ' placeholder fields). For HTML fields you can use the special variable @theme to use theme colors (ex: @them.palette.themePrimary ). If you don't set a value for those fields (i.e an empty value), they won't appear in the UI: Enable result preview If enabled, displays a preview callout when the card image is clicked. This will works for office documents, pdf and Office 365 videos. Show file icon Hide or display the file icon in the card. Compact mode Display the cards in compact mode. Numbre of preferred cards per row Try to displays the selected number of cards in the current section. Because a card has a mininum width, the layout will always try to fit the maximum of cards inside the current Web Part section until reaching the layout option value you set. For example, if you specified five cards in a row but the Web Part is rendered in a single vertical section, only one card per row will be displayed regardless the option value. However, if you expand the Web Part in a full width column, the five cards per row will be displayed. This behavior ensures the layout will always render nicely in responsive scenarios.","title":"Cards layout"},{"location":"templating/guidelines/#details-list-layout","text":"When you enable sorting for a column, the sort is performed on the initial item fiel value , not on the Handlebars expression if provided. If this option is checked, you can choose the item field to use to determine the right icon for instance ( .docx ).","title":"Details List Layout"},{"location":"templating/guidelines/#work-with-result-types","text":"A result types feature is available for List, Cards and Custom layouts. If you need to apply conditional result in the slider component, use direct conditions like {{#if}} inside the slider component.","title":"Work with result types"},{"location":"templating/tokens/","text":"Available tokens \u00b6 All tokens are case insensitive and will be resolved as string values. Also, these tokens can be used for all built-in data sources. Paging tokens \u00b6 Use these tokens to implement your own paging logic to get context information from the Web Part. Token Description {itemsCountPerPage} The number of items to display per page configured in the data source paging options in the property pane. {startRow} Corresponds to the number or items per page * the current page number (starting from 0). {searchBoxQuery} TODO Current page tokens \u00b6 Use these tokens to get column values from the current page. Token Description {Page.<FieldName>} The value of a field on the page from where the query was issued. For example, if the page from where the query was issued contained a site column named \"ContentOwner,\" specifying {Page.ContentOwner} would allow you to query for the value of \"ContentOwner.\" FieldName is the internal name of the field. When used with taxonomy columns, use {Page.<FieldName>.Label} or {Page.<FieldName>.TermID} Context tokens \u00b6 Use these tokens to get information about the current page context. These tokens surfaces information available trough the native SPFx PageContext class. Refer to https://docs.microsoft.com/en-us/javascript/api/sp-page-context/pagecontext?view=sp-typescript-latest to get available properties you can use for these tokens. Unless other tokens, all property names are case sensitive . Token Description **{Site.\\ }** Contextual information for the SharePoint site collection that is hosting the page. For example {Site.serverRelativeUrl} . **{Web.\\ }** Contextual information for the SharePoint web that is hosting the page. For example {Web.title} . **{List.\\ }** Contextual information for the SharePoint list item that is hosting the page. If there is no list item associated to the current page, this property will be undefined.. For example {List.title} . **{Hub.\\ }** Contextual information about the hub site if the current site is configured as hub. For example {Hub.id} . **{Group.\\ }** Contextual information about the O365 Group associated with this site. If there is no Office 365 group associated with the current site, this property will be undefined. Use the debug layout view to see available values. **{LegacyPageContext.\\ }** A value from the legacyPageContext object on the page. For example, if the legacyPageContext object of the current page contains a property \"hubSiteId\": \"166aa115-7ae7-4c21-9e02-9e0c8872be28\", you could obtain the value 166aa115-7ae7-4c21-9e02-9e0c8872be28 by specifying {LegacyPageContext.hubSiteId} User tokens \u00b6 Use these tokens to get property values from the current connected user. Token Description **{User.\\ }** Any property from the user profile of the user who issued the query \u2014 for example, {User.SPS-Interests} , including custom properties. Date tokens \u00b6 Use these tokens to build dynamic date based conditions. Token Description {Today} The current date and time as YYYY-MM-DDTHH:mm:ssZ format. **{Today} +/- \\ }** A date calculated by adding/subtracting the specified number of days to/from the date when the query is issued. Date format is YYYY-MM-DDTHH:mm:ssZ. For example, this value can be used to query content of the managed property LastModifiedTime . Also 'A week ago' token would be {Today} - 7 and 'Last year' {Today} - 365 . Query string tokens \u00b6 Use these tokens to retrieve informations from the URL query string parameters. Token Description {QueryString.<ParameterName>} A value from a query string in the URL of the current page. For example, if the URL of the current page contains a query string such as ItemNumber=567, you could obtain the value 567 by specifying {QueryString.ItemNumber} . Search Data source specific tokens \u00b6 When you use SharePoint search data source , you can additionnaly use these tokens, supported natively in the query template value. TODO","title":"Tokens"},{"location":"templating/tokens/#available-tokens","text":"All tokens are case insensitive and will be resolved as string values. Also, these tokens can be used for all built-in data sources.","title":"Available tokens"},{"location":"templating/tokens/#paging-tokens","text":"Use these tokens to implement your own paging logic to get context information from the Web Part. Token Description {itemsCountPerPage} The number of items to display per page configured in the data source paging options in the property pane. {startRow} Corresponds to the number or items per page * the current page number (starting from 0). {searchBoxQuery} TODO","title":"Paging tokens"},{"location":"templating/tokens/#current-page-tokens","text":"Use these tokens to get column values from the current page. Token Description {Page.<FieldName>} The value of a field on the page from where the query was issued. For example, if the page from where the query was issued contained a site column named \"ContentOwner,\" specifying {Page.ContentOwner} would allow you to query for the value of \"ContentOwner.\" FieldName is the internal name of the field. When used with taxonomy columns, use {Page.<FieldName>.Label} or {Page.<FieldName>.TermID}","title":"Current page tokens"},{"location":"templating/tokens/#context-tokens","text":"Use these tokens to get information about the current page context. These tokens surfaces information available trough the native SPFx PageContext class. Refer to https://docs.microsoft.com/en-us/javascript/api/sp-page-context/pagecontext?view=sp-typescript-latest to get available properties you can use for these tokens. Unless other tokens, all property names are case sensitive . Token Description **{Site.\\ }** Contextual information for the SharePoint site collection that is hosting the page. For example {Site.serverRelativeUrl} . **{Web.\\ }** Contextual information for the SharePoint web that is hosting the page. For example {Web.title} . **{List.\\ }** Contextual information for the SharePoint list item that is hosting the page. If there is no list item associated to the current page, this property will be undefined.. For example {List.title} . **{Hub.\\ }** Contextual information about the hub site if the current site is configured as hub. For example {Hub.id} . **{Group.\\ }** Contextual information about the O365 Group associated with this site. If there is no Office 365 group associated with the current site, this property will be undefined. Use the debug layout view to see available values. **{LegacyPageContext.\\ }** A value from the legacyPageContext object on the page. For example, if the legacyPageContext object of the current page contains a property \"hubSiteId\": \"166aa115-7ae7-4c21-9e02-9e0c8872be28\", you could obtain the value 166aa115-7ae7-4c21-9e02-9e0c8872be28 by specifying {LegacyPageContext.hubSiteId}","title":"Context tokens"},{"location":"templating/tokens/#user-tokens","text":"Use these tokens to get property values from the current connected user. Token Description **{User.\\ }** Any property from the user profile of the user who issued the query \u2014 for example, {User.SPS-Interests} , including custom properties.","title":"User tokens"},{"location":"templating/tokens/#date-tokens","text":"Use these tokens to build dynamic date based conditions. Token Description {Today} The current date and time as YYYY-MM-DDTHH:mm:ssZ format. **{Today} +/- \\ }** A date calculated by adding/subtracting the specified number of days to/from the date when the query is issued. Date format is YYYY-MM-DDTHH:mm:ssZ. For example, this value can be used to query content of the managed property LastModifiedTime . Also 'A week ago' token would be {Today} - 7 and 'Last year' {Today} - 365 .","title":"Date tokens"},{"location":"templating/tokens/#query-string-tokens","text":"Use these tokens to retrieve informations from the URL query string parameters. Token Description {QueryString.<ParameterName>} A value from a query string in the URL of the current page. For example, if the URL of the current page contains a query string such as ItemNumber=567, you could obtain the value 567 by specifying {QueryString.ItemNumber} .","title":"Query string tokens"},{"location":"templating/tokens/#search-data-source-specific-tokens","text":"When you use SharePoint search data source , you can additionnaly use these tokens, supported natively in the query template value. TODO","title":"Search Data source specific tokens"}]}